\section{Requirements from Coarray Features}\label{sec:spec}

XMP Fortran language specification supports a major part of coarray features defined in 
Fortran~2008 standard~\cite{F08}, and intrinsic procedures 
{\tt CO\_SUM}, {\tt CO\_MAX}, {\tt CO\_MIN} and {\tt CO\_BROADCAST} defined in 
Fortran~2018 standard~\cite{F18} were supported.
And also XMP C language specification extended to support coarray features.

This section introduces the coarray features and what is required
to the compiler in order to implement the coarray features.


%-----------------------------------------------------------------------------
\subsection{Images Mapped to XMP Nodes}\label{sec:spec-image}
%-----------------------------------------------------------------------------

In the Fortran standard, an {\bf image} is defined as a instance of a program. 
Each image executes the same program and has its own data individually 
(SPMD: Single Program/Multiple Data).
Each image has a different image index, which is one of $1, \cdots, n$, 
where $n$ is the number of images determined at runtime. 
While the Fortran standard does not define where each image is executed, 
XMP defines the mapping of the images to the executing nodes as follows;
image $k$ is always executed on executing node $k$, 
where $1 \leq k \leq n$ and 
$n$ is the number of images and also the number of the executing nodes. 
In addition, since each MPI rank number of {\tt MPI\_COMM\_WORLD} (0-origin) is 
always mapped to an XMP node number in order, local data on image $k$ can be
accessed with MPI functions as data on rank $(k - 1)$.

Note that the executing nodes can be a subset of the entire (initial) node set. 
For example, two distinct node sets can execute two coarray subprograms concurrently.
The first executing images at the start of the program is the entire images.
Coarray features are compatible to the ones of the Fortran standard unless 
the {\tt TASK} and {\tt END TASK} directives are used.
If the execution encounters a {\tt TASK} directive specified with a subset of nodes, 
the corresponding subset of the images will be the executing images for the task region. 
The current number of images and my image number, which are given by inquire functions
{\tt num\_images} and {\tt this\_image}, also match with the executing images, and
the {\tt SYNC\_IMAGES} statement synchronizes among the executing images.
When the execution encounters the {\tt END TASK} directive corresponding to the
{\tt TASK} directive, the set of executing image is reinstated.

%   Coarray features can be used inside the TASK directive blocks. As default,
%   each coarray image is mapped one-to-one to a node of the current executing 
%   task. I.e., num_images() returns the number of nodes of the current executing 
%   task and this_image() returns each image index in the task.
%      There are two directives to change the default rule above. A COARRAY 
%   directive corresponding to a coarray declaration changes the image index set 
%   of the specified coarray with the one of the specified nodes. An IMAGE 
%   directive corresponding to one of a SYNC ALL statement, a SYNC IMAGES 
%   statement, a call statement calling CO_SUM, CO_MAX, CO_MIN or CO_BROADCAST 
%   changes the current image index set with the one of the specified nodes.
%   See the language spacifications [3].

\requirement
%Memory management is necessary to cope with changes of the executing images.
The runtime library should change the executing image set and my position of the set 
at the entry point of the task, and reinstate them at the exit point of the task.

%The XMP compiler manages these values in stack.
%タスク実行のときのスタックの使い方、構文が入れ子なので同じレベルに戻ることができること。


%-----------------------------------------------------------------------------
\subsection{Allocation of Coarrays}\label{sec:spec-coarray}
%-----------------------------------------------------------------------------

A {\bf coarray} or a coarray variable is a variable that can be referred from the other images. 
A coarray with the {\tt ALLOCATABLE} attribute is called an {\bf allocatable coarray}, 
otherwise called a non-allocatable coarray. A non-allocatable coarray may not be a pointer 
and must have an explicit shape and the {\tt SAVE} attribute. In order to help 
intuitive understanding, we call a non-allocatable coarray as a {\bf static coarray}. 
The lifetime of a static coarray is throughout execution of the program on all images even if
the coarray is declared in a procedure called with a subset of images.

On the other hand, an allocatable coarray is allocated with the {\tt ALLOCATE} statement and 
freed either explicitly with the {\tt DEALLOCATE} statement or implicitly at the end of the 
scope in which the {\tt ALLOCATE} statement is executed ({\bf automatic deallocation}).

Static coarrays can be declared as scalar or array variables as follows:
\begin{verbatim}
      real(8), save :: a(100,100)[*]
      type(user_defined_type), save :: s[2,2,*]
\end{verbatim}

The square bracket notation in the declaration distinguishes coarray variables from 
the others (non-coarrays). It declares the virtual shape of the images and the last 
dimension must be deferred (as `{\tt *}').

Allocatable coarrays can be declared as follows:
\begin{verbatim}
      real(8), allocatable :: b(:,:)[:]
      type(user_defined_type), allocatable :: t[:,:,:]
\end{verbatim}


A notable constraint is that at any synchronization point in program execution, 
coarrays must have the same dimensions (sizes of all axes) between all images
({\bf symmetric memory allocation}). 
Therefore, an static coarray must have the same shape between all images during 
the program execution, and an allocatable coarray must be allocated and deallocated 
collectively at the same time with the same dimensions between the executing images.
Thanks to the syn-metric memory allocation rule, all executing images can have
the same symmetrical memory layout, which makes it possible to calculate the address 
of the remote coarray with no prior inter-image communication.

% 2. Declaration
%   Either static or allocatable coarray data objects can be used in the program. 
%   Use- and host-associations are available but common- or equivalence-
%   association are not allowed in conformity with the Fortran2008 standard.
%   Current restrictions against Fortran2008 coarray features:
%     * Rank (number of dimensions) of an array may not be more than 7.
%     * A coarray cannot be of a derived type nor be a structure component.
%     * A coarray cannot be of quadruple precision, i.e., 16-byte real or 32-byte 
%       complex.
%     * Interface block cannot contains any specification of coarrays. To describe
%       explicit interface, host-assocication (with internal procedure) and use-
%       association (with module) can be used instead.
%     * A pointer component of a derived-type coarray is not allowed.
%     * An allocatable component of a derived-type coarray cannnot be referrenced
%       as a coindexed object.
%     * A derived-type coarray cannot be defined as allocatable.

% 2.1  Static Coarray
%   E.g.
%       real(8) :: a(100,100)[*], s(1000)[2,2,*]
%       integer, save :: n[*], m(3)[4,*]
%   The data object is allocated previously before the execution of the user 
%   program.  A recursive procedure cannot have a non-allocatable coarray without 
%   SAVE attribute.
%   Current restrictions against Fortran2008 coarray features:
%     * Each lower/upper bound of the shape must be such a simple expression that 
%       is an integer constant literal, a simple integer constant expression, or
%       a reference of an integer named constant defined with a simple integer 
%       constant expression.
%     * A coarray cannot be initialized with initialization or with a DATA 
%       statement.
%     
% 2.2  Allocatable Coarray
%   E.g.
%       real(8), allocatable :: a(:,:)[:], s(:)[:]
%       integer, allocatable, save :: n[:], m(:)[:,:]
%   The data object is allocated with an ALLOCATE statement as follows:
%       allocate ( a(100,100)[*], s(1000)[2,2,*] )
%   The allocated coarray is deallocated with an explicit DEALLOCATE statement or 
%   with an automatic deallocation at the end of the scope of the name unless it 
%   has SAVE attribute.
%   Current restrictions against fortran2008 coarray features:
%     * A scalar coarray cannot be allocatable.
%     * An allocatable coarray as a dummy argument cannot be allocated or 
%       deallocated inside the procedure.

\requirement
Static coarrays must be allocated and made accessible remotely
before the execution of the user program, and 
made inaccessible remotely and be freed after the execution of the user program.
In contrast, 
allocatable coarrays must be allocated and made accessible remotely
when the {\tt ALLOCATE} statement is encountered, and 
made inaccessible remotely and be freed when the {\tt DEALLOCATE} statement or 
the exit point of the scope that the corresponding {\tt ALLOCATE} statement is encountered 
is encountered.


%-----------------------------------------------------------------------------
\subsection{Communications}\label{sec:spec-comm}
%-----------------------------------------------------------------------------

Coarray features include three types of communications between images, i.e.,
\begin{itemize}
\item reference and definition to remote coarrays (GET and PUT communication),
\item collective communication (intrinsic subroutines {\tt CO\_SUM}, {\tt CO\_MAX}, 
{\tt CO\_MIN} and {\tt CO\_BROADCAST}), and
\item atomic operations ({\tt ATOMIC\_DEFINE} and {\tt ATOMIC\_REF}).
\end{itemize}

Omni compiler implements the latter two communications using the corresponding 
functions in MPI. The rest of this section describes the former communication.

%===========================================================
\subsubsection{PUT communication}\label{sec:spec-put}
%===========================================================

PUT communication is caused by an assignment statement with a {\bf coindexed variable} 
as the left-hand side expression, e.g.,
\begin{verbatim}
      a(i,j)[k] = alpha * b(i,j) + c(i,j)
\end{verbatim}
This statement is to cause the PUT communication to the array element $a(i,j)$ on image $k$
with the value of the left-hand side.

Fortranの配列代入文を使えば、配列から配列へのPUT通信を記述することもできる。
例えば以下の配列代入文は、$M N$ 要素のPUT通信を生じさせる。
\begin{verbatim}
      a(1:M,1:N)[k] = alpha * b(1:M,1:N) + c(1:M,1:N)
\end{verbatim}

\requirement
配列代入文では、一般には右辺の評価結果をFortranシステムが一時領域に置くが、
通信バッファをできる限り多重にしない工夫が必要である。
右辺が配列の参照だけの場合はゼロコピー通信とすることが望ましい。

% ダブリ。同期の方で言う。
%また、次のimage制御文によって同期が行われるまでPUTされたデータは他のimageから
%参照されないので、実行はPUT通信の完了を待たないで次に進むことができる
%（non-blocking communication）。


%===========================================================
\subsubsection{GET communication}\label{sec:spec-get}
%===========================================================

GET communication is caused by referencing the {\bf coindexed object}, 
which is represented by a coarray variable with cosubscripts enclosed by square brackets, 
e.g., $s[1,2]$ and $a(i,j)[k]$, where $s$ and $a$ are scalar and two-dimensional array coarrays,
respectively.
Coindexed objects can appear in most expressions.

値を配列とする配列式を使うと配列に対するGET通信を行うことができる。
例えば coindexed-object $a(1:M,1:N)[k]$ の値は$a$と同じ型で形状$[M, N]$の2次元配列である。


\requirement
ローカル側は、獲得したデータがすぐに消費されることからnon-blocking化は適さない。
バッファリングを回避してゼロコピーとすることで効率化したい。
通常は式の引用に対して（それが配列式であっても）ライブラリに変換するが、
右辺に１つのcoindexed-objectしかない配列代入文は、最適化として文全体をライブラリに
変換する。例えば、
\begin{verbatim}
      a(1:M,1:N) = b(1:M,1:N)[k]
\end{verbatim}
では、aがDMAの要件を満たす場合には、受信先をバッファでなく直接aにすることで、
ゼロコピーにできる。


%-----------------------------------------------------------------------------
\subsection{Inter-image Synchronization}\label{spec-sync}
%-----------------------------------------------------------------------------
Basically, the Fortran language specification does not guarantee the inter-image 
data dependency unless any image control statements are explicitly used.
\fig{sync-ex} shows an example of program fragment describing inter-image communication
and synchronization by the reference and definition of coarrays and {\tt SYNC ALL} statement.
Here, all variables {\tt a}, {\tt b}, {\tt c}, {\tt x}, {\tt y} and {\tt z} are coarrays.
%
An {\bf image control statement}, such as {\tt SYNC ALL} and {\tt SYNC IMAGES} statements, 
separates a procedure into {\bf segments}. In \fig{sync-ex}, portions between lines~2 and 9 and 
between lines~11 and 20 are segments.
The synchronization between images does not need to complete until encountering the 
image control statements. And the compiler optimization does not allowed to perform 
the code motion across the image control statement. In \fig{sync-ex}, 
{\tt sync all} in line~10 should wait for completion of the definition to coarray {\tt a} 
in line~4, and should prevent the code motion of lines~4 and 5 and lines~16, 17 and 19 
from crossing the {\tt sync all} in line~10.

緩い同期である。ここに最適化のチャンスがある。

\begin{figure}[hbt]
 \begin{center}
\begin{verbatim}
 1      sync all
 2
 3      if (this_image()==1) then
 4          a[2]=
 5          b[2]=
 6          =c[2]
 7          x=
 8          y=
 9          =z
10      endif
11
12      sync all
13
14      if (this_image()==2) then
15          =a
16          b=
17          c=
18          =x[1]
19          y[1]=
20          z[1]=
21      endif
22
23      sync all

\end{verbatim}
  \caption{Example of inter-image synchronization}
  \label{fig:sync-ex}
 \end{center}
\end{figure}



各イメージの中では、従来のFortran仕様に従う依存関係の維持が必要である。
non-coarrayデータに関しては従来とおりだが、coarrayについて注意が必要。
In order to keep data dependency among the definitions and 
references in the coarray, the non-blocking communication should be restricted.
\fig{block-ex} にdata dependencyに気をつけなければならない例を示す。
同じリモートデータに対して同じsegment内で複数回アクセスする場合である。

\begin{figure}[hbt]
 \begin{center}
\begin{verbatim}
 1      if (this_image()==2) then
 2          a[2]=
 3          =a[2]     ! should wait for the completion of line 2 to keep flow dependency.
 4          a[2]=     ! should wait for the completion of line 3 to keep anti dependency.
 5      endif

\end{verbatim}
  \caption{Example of intra-image communication blocking}
  \label{fig:block-ex}
 \end{center}
\end{figure}


\requirement
To reduce the latency overhead, non-blocking one-sided communication is effective.
The compiler should generate non-blocking GET communication as long as possible.
In usual case, the completion point of the non-blocking is the end of the segment, as
shown in \fig{sync-ex}.  However, the possibility to meet the condition shown in
\fig{block-ex} should be took account. If the PUT communication is always in blocking, 
only the flow dependency should be care; the previous PUT communication (line~2) 
should be completed before the following GET communication (line~3).

%-----------------------------------------------------------------------------
\subsection{Subarrays and Data Contiguity}\label{sec:spec-contig}
%-----------------------------------------------------------------------------

In Fortran, if an array, except dummy argument, is declared as {\tt real a(1:M,1:N)}, 
the reference to the whole array (i.e., {\tt a} or {\tt a(:,:)} or {a(1:M,1:N)})
is defined {\bf contiguous}. 
We defined a term {\bf contiguous length} as the length how long the data is partially
contiguous. For example, the contiguous lengths of {\tt a(2,3)} and {\tt a(2:5,3)} are
1 and 4 respectively.  {\tt a(1:M,1:3)} is two-dimensionally contiguous and has 
contiguous length $2 \times {\tt M}$.
{\tt a(1:M-1,1:3)} is one-dimensionally contiguous and has 
contiguous length $({\tt M} - 1)$.


\requirement
通信の高速化のためには，十分に長い範囲の連続性を実行時に抽出する必要がある．
一般にノード間通信で立ち上がりレイテンシ時間がほぼ無視できるようになるデータ量は
数千バイトであることから，配列や部分配列の1次元め（Fortranでは1番左の添字）が
連続であっても数千要素に満たない場合には，次元を跨いだ連続性まで抽出して，
十分に長い連続データとして通信する技術が必要である．
【fx100-latencyのグラフから数千バイトを言ってもよい。】

GET通信と同様，a(i,j)[k]は代わりに全体配列にも部分配列にもなれるので，
coindexed variableについても次元を跨いだ連続性の抽出が必要である．
それに加えて、ローカル側、すなわち、右辺式データの連続性も意識に入れなければならない。
高速な通信を実現するには，左辺と右辺で共通に連続な区間を検出してその単位で通信を反復するか，
右辺データは連続区間にpackして左辺の連続区間を単位として通信を反復するなどの戦略がある。



%-----------------------------------------------------------------------------
\subsection{Coarray C Language Specifications}\label{sec:spec-c}
%-----------------------------------------------------------------------------

C言語にも配列式、配列代入を導入することでFortranと同様なcoarray featuresを仕様定義した。

coarrayはデータ実体に限る。ポインタはcoarrayになれない。形式的には、
1)基本型、2)ポインタを含まない構造型、または、3) 1or2or3の配列とする。
Cのcoarrayにおいてもstaticとallocatableがある。ファイル直下で宣言するか
static指示したcoarrayはstatic coarrayである。ライブラリ関数xxxをつかって
割付けたデータ領域はallocatable coarrayであり、ライブラリ関数は
allocatable coarrayへのポインタを返す。
Cのcoarrayは、通常のCの変数と同じように、引数渡しやcast演算によって自由に
その型と形状の解釈を変えることができる。

これらの仕様と制限は、Cプログラマ
にとっての使いやすさを考えて、Cらしいプログラミングスタイルを認めた。
Coarray C++とは違うアプローチである。

cf.\ air:/Users/iwashita/Desktop/coarray/Project\_Coarray/の下にいくつか
