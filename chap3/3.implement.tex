\section{Implementation}\label{sec:implement}

%-----------------------------------------------------------------------------
\subsection{Omni XMP Compiler Framework}
%-----------------------------------------------------------------------------

The CAF translator was added into the Omni XMP compiler~\cite{omni} 
as shown in Figure~\ref{fig:translator}.
The Omni XMP compiler is a source-to-source translator that converts XMP programs 
into the base language (Fortran or C).  The component `coarray translator' is 
located in front of the XMP translator to solve coarray features previously. 
The output of the decompiler is a standard Fortran/C program that may include 
calls to the XMP runtime library.

The following procedures are generated in advance or in the coarray translator
to initialize static coarray variables prior to the execution of the user program:
\begin{itemize}
\item
The built-in main program calls subroutine {\tt xmpf\_traverse\_init},
the entry procedure of initialization subroutines, before executing the
user main program.
\item
Subroutine {\tt xmpf\_traverse\_init} is generated by the coarray translator 
to call initialization subroutines corresponding to all user-defined procedures.
\item
Each initialization subroutine {\tt xmpf\_init\_{\it foo}} is generated from 
user-defined procedure {\it foo} by the coarray translator. 
It initializes all static coarrays declared in {\it foo}.
\end{itemize}

\begin{figure}[tbh]
 \begin{center}
  % trimはleft bottom right topの順
  %\includegraphics[scale=0.55,trim=6cm 0cm 4cm 6cm,clip]{figs/translator-tmp.pdf}
  \includegraphics[trim=30mm 0mm 20mm 7mm, scale=1.0]{figs/translator-tmp.pdf}
  \caption{XMP compiler and an example of coarray program compilation}
  \label{fig:translator}
  %-- 修正すべき箇所
  CAF translator $\rightarrow$ coarray translator
 \end{center}
\end{figure}


%-----------------------------------------------------------------------------
\subsection{Allocation and Registration}\label{sec:alloc}
%-----------------------------------------------------------------------------

To be accessed using the underlying communication library,
the allocated coarray data must be registered to the library.
The registration contains all actions to allow the data to be accessed 
from the other nodes, including pin-down memory, acquirement of the global address,
and sharing information among all nodes.

%===========================================================
\subsubsection{Three methods of memory management}
%===========================================================

The coarray translator and the runtime library implements three methods of
memory management.
\begin{itemize}
\item
The {\bf Runtime Sharing (RS) Method} allocates and registers a large memory 
for all static and dynamic coarrays at the initialization phase.
The registered memory is shared by all static and allocatable coarrays. 

\item
The {\bf Runtime Allocation (RA) Method} allocates and registers a large memory
for all static coarrays at the initialization phase.
And it allocates and registers each allocatable coarray at runtime.

\item
The {\bf Compiler Allocation (CA) Method} allocates all coarray objects by 
the Fortran system (at compile time or at runtime) and the address is 
passed to the runtime library to be registered.
\end{itemize}

For the RS and RA methods, 
because the allocated memory address is determined in the runtime library, 
the object code must accept the address allocated 
inside the runtime system as an address of a regal Fortran variable.
To make this connection, it was necessary to use the Cray pointer, which is not 
in the Fortran standard.
In the case of the CA method, the runtime library accepts the address allocated
in the Fortran system, and registers to the communication library.

%
% 3 methodsの比較表を載せるならここか
%


%===========================================================
\subsubsection{Initial Allocation for Static Coarrays}
%===========================================================

Static coarrays are allocated and registered in the initialization subroutines 
{\tt xmpf\_init\_{\it foo}}. 

On the RS and RA methods,
static coarrays are initialized before the execution of the user program,
as follows.
\begin{itemize}
\item
In the first pass, all sizes of static (non-allocatable) coarrays are summed.
The size of each static coarray is evaluated form the lower and upper bounds
specified in the dimension declaration statement of each coarray.
The lower and upper bound expressions, possibly including binary and unary
operations, reference to name of constants, and basic intrinsic functions 
such as min/max and sum, are evaluated by constant folding techniques.
Since the size of the structure that contains allocatable or pointer 
components differs depending on for the target compiler, the coarray translator
get the necessary parameters to calculate the size of structures at the build time.
\item
Then, the total size of static coarrays is allocated and the address
and the size is registered to the underlying communication library.
\item
In the second pass, the addresses of the all coarrays are calculated to share
the registered data.
Due to the language specification, sizes of the same coarray are the same 
among all images (nodes). So the offset from the base address of the registered 
data for each coarray can be the same among all images.
\end{itemize}
%
In the RS method, allocatable coarrays are also shared the registered memory. 
The total size of the memory to be registered
should be specified with an environment variable by the user.
While in the RA method, the total size is fully calculated by the runtime 
library and no information is required to the user because allocatable coarrays
will be dynamically allocated on the other memories.

On the CA method,
the Fortran processor allocates each coarray and then the runtime library
registers the address.
Each static coarray is converted into a common (external) variable to share 
between the user-defined procedure (say {\it foo}) and its initialization
procedure ({\tt xmpf\_init\_{\it foo}}). The data is statically allocated
by the Fortran system similarly to the usual common variable.
the address is registered in the initialization procedure via the runtime
library.


%===========================================================
\subsubsection{Runtime Allocation for Allocatable Coarrays}
%===========================================================

For the RS method, the runtime library has a memory management system for
cutting out and retrieving memory for each allocation and deallocation of 
coarrays.

Figure~\ref{fig:register-RA-CA} illustrates the memory allocation and registration
for allocatable coarrays on the RA and CA methods. 

\begin{figure}
 \begin{center}
  \includegraphics[scale=0.9, trim=0mm 0mm 0mm 0mm, clip]{figs/register-RA-tmp.pdf}\\
The runtime allocates and registers coarrays and passes the address to the user code.
 \end{center}
 \begin{center}
(a) RA method
 \end{center}
 \begin{center}
  \includegraphics[scale=0.9, trim=0mm 0mm 0mm 0mm, clip]{figs/register-CA-tmp.pdf}\\
The user code allocates coarrays and causes the runtime to register with the address.
 \end{center}
 \begin{center}
(b) CA method
 \end{center}
 \caption{Memory allocation for coarrays in RA and CA methods}
 \label{fig:register-RA-CA}
\end{figure}

These methods are properly used by the underlying communication library.
%
On GASNet, only the RS method is adopted because its allocation function
can be used only once in the program.
%
On MPI-3, the CA method is not suitable because frequent 
allocation and deallocation of coarrays cause expensive creation and freeing 
MPI windows.
%
Over FJ-RDMA, the RS method has no advantage over the other methods.
Since the allocated address is used for registration to FJ-RDMA, 
no advantage was found for managing memory outside of the Fortran system. 
The unusual connection through the Cray pointer causes the degrade of 
the Fortran compiler optimization.


%-----------------------------------------------------------------------------
\subsection{PUT/GET Communication}\label{sec:putget}
%-----------------------------------------------------------------------------

To avoid disturbing the execution on the remote image, PUT and GET communications
are implemented always using Remote Direct Memory Access (RDMA) provided by 
the communication library (except coarrays with pointer/allocatable structure components). 
In contrast, local data access is selective between using Direct Memory Access (DMA) or
using a local buffer. For the buffer scheme, one of four algorithms will be chosen.


%===========================================================
\subsubsection{Determining the possibility of DMA}\label{sec:opt-dma}
%===========================================================

Coarray variables must be registered when allocated to be 
the target of RDMA communication. In contrast, since the local
data, which is the source of PUT or the destination of GET,
was not registered or not linked to registered information,
it could not to be the target of DMA communication.
It had to be communicated via the registered buffer.

When the local data is an entire or a part of coarray,
the coarray must be registered and efficient DMA-RDMA communication can 
be made. Since the analysis at compile time is limited,
we had implemented the detector in the runtime library 
using binary-tree search as follows.
%
\begin{enumerate}
\item
When a chunk of coarray data is registered to the communication library, 
runtime library adds the set of the local address and the size into a sorted 
table called {\tt SortedChunkTable}. The sort key is the local base address
of the data.
\item
When a chunk of coarray data is deregistered from the communication library, 
runtime library deletes the record in {\tt SortedChunkTable}.
\item
When a PUT or GET runtime library is called corresponding to a reference/definition
to a coindexed object/variable, the local address is searched in {\tt SortedChunkTable}
with binary search. The local data is already registered if 
$addr_i \leq addr < addr_i + size_i$ for any $i$,
where $addr$ is the said local address and $add_i$ and $size_i$ are the
$i$-th address and size in {\tt SortedChunkTable}, respectively.
\end{enumerate}

If the communication data is large, the cost of procedure 3 is relatively small enough
and it is worth to be used. 
If the data is small, buffering algorithm as shown in \Sec{buffer} may be better.


%===========================================================
\subsubsection{Buffering Communication Methods}\label{sec:buffer}
%===========================================================

For the buffer scheme, one of four algorithms will be chosen 
depending on three parameters, the size of the local buffer $B$ and the 
local and remote contiguous lengths $N_L$ and $N_R$.
$B$ should be large enough to ignore communication latency overhead and we use
about 400 kilo-bites in default. Unlike the case of MPI message passing,
coarray PUT/GET communication requires only one local buffer for any numbers of
other images.
$N_L$ and $N_R$ can be evaluated at runtime. The Fortran syntax guarantees 
that $N_L$ is a multiple of $N_R$ or $N_R$ is a multiple of $N_L$.
An algorithm to get the contiguous length is shown in the paper~\cite{pgas15}.

\tab{putget} summarizes our algorithm for PUT/GET communication for five cases.
The unit size is the chunk length of the PUT/GET communication.
Case~0 shows the algorithm using RDMA-DMA PUT/GET communication and Cases~1 through~4
shows the algorithms using RDMA and local-buffering. 
Due to its strict condition, the DMA scheme is rarely used.
And it is not always faster than the buffering scheme cases~2 and~3 because of the 
difference of the unit sizes. The merit of cases~2 and~3 is that the unit size 
is extended to a multiple of $N_L$ by gathering number of short contiguous data in the buffer,
or by scattering from the buffer into number of short contiguous data.

\begin{table}[tbh]
 \caption{Summary of the PUT/GET algorithm related to $N_L$, $N_R$ and $B$}
 \label{tab:putget}
 \begin{flushleft}
  \begin{tabular}{|@{~}c@{~}|c||@{~}c@{~}|@{~}c@{~}|}
\hline
scheme &
case &
condition &
unit size \\
\hline
\hline
DMA &
&
Local data is registered. &
$\min(N_L, N_R)$ \\
\hline
buffering &
1 & 
$N_R \leq B,~ N_R \leq N_L$ &
$N_R$ \\
\cline{2-4}
&
2 &
$N_L < N_R \leq B$ &
$N_R$ \\
\cline{2-4}
&
3 &
$N_L < B < N_R$ &
multiple of $N_L$ ($\leq B$) \\
\cline{2-4}
&
4 &
$B < N_R,~ B \leq N_L$ &
$B$ (or less than $B$ at last) \\
\hline
  \end{tabular}
 \end{flushleft}
 \begin{flushleft}
  \begin{tabular}{|@{~}c@{~}|c||@{~~}l@{~~}|@{~~}l@{~~}|}
\hline
scheme &
case &
PUT action for each unit &
GET action for each unit \\
\hline
\hline
DMA &
&
put once &
get once \\
\hline
buffering &
1 &
buffer once and put once &
get once and unbuffer once \\
\cline{2-4}
&
2 &
buffer for each $N_L$, and put once &
get once, and unbuffer for each $N_L$ \\
\cline{2-4}
&
3 &
buffer for each $N_L$, and put once &
get once, and unbuffer for each $N_L$ \\
\cline{2-4}
&
4 &
buffer once and put once &
get once and unbuffer once \\
\hline
  \end{tabular}
 \end{flushleft}
\end{table}


%===========================================================
\subsubsection{Non-blocking PUT communication}
%===========================================================

For higher performance, the PUT communication should be in non-blocking and
the completion wait should be delayed to the end of the segment.
It seems a very rare case that writing and reading the same remote data from
the same image in the same segment, as described in \Sec{spec-sync}.
However, it is difficult to detect with low cost. Because the subscripts and image
indices are often variable expressions, the compiler rarely select non-blocking
and usually generates safe but slow code.
We do not have reasonable solution for this issue.

In the current implementation, the user selects blocking or non-blocking for
PUT communication at runtime with the environment variable.
%ほとんどの場合には該当しないことを利用者が分かるので、non-blockingのオプションを
%選択することを期待する。


%===========================================================
\subsubsection{Optimization of GET communication}\label{sec:opt-get}
%===========================================================

A reference to an array coindexed object is converted to a call of a runtime library 
function that returns a Fortran array value. For example, array assignment statement:
\begin{verbatim}
 b(j1:j2) = a(i1:i2)[k] 
\end{verbatim}
is converted to:
\begin{verbatim}
 b(j1:j2) = xmpf_coarray_get_generic(dp_a,k,a(i1:i2)) 
\end{verbatim}
by the coarray translator, where {\tt dp\_a} is the descriptor of coarray {\tt a}.
The issue is the result of the library function is an array value, which
causes several numbers of memory copies.
% The result value of the function is one-dimensional array whose size 
% is $({\tt i2} - {\tt i1} + 1)$.
% The issue is that it tends to cause many data copies in some library layers.
As a countermeasure, we optimized specific but common case by the translator.
If a coindexed object is only the right-hand side of an array assignment statement,
the entire assignment statement can be converted into one library call.
The example above satisfies the condition, so it can be converted again as follows:
\begin{verbatim}
 call xmpf_coarray_getsub_generic(dp_a,k,a(i1:i2),b(j1:j2)) 
\end{verbatim}
In this runtime library subroutine, the variable {\tt b(j1:j2)} is expected to be 
the local target of GET communication instead of the local buffer that would be
generated by the Fortran runtime.


%-----------------------------------------------------------------------------
\subsection{Runtime Libraries}\label{sec:runtime}
%-----------------------------------------------------------------------------

The layer of the runtime libraries are shown in \fig{layer}.
One of three communication libraries is selected 
at the build time of the Omni compiler.
The coarray runtime consists of layered three libraries.
%
The {\bf Fortran wrapper} mediates the arguments and the result value 
of the translated user program (written in Fortran) and ULR (written in C).
%
The {\bf upper-layer runtime (ULR) library} performs the algorithms 
described above in this section.
%
The {\bf lower-layer runtime (LLR) library} abstracts the difference between 
the communication libraries except the memory management of coarray data.

\begin{figure}[tbh]
  \begin{center}
    % trimはleft bottom right topの順
    %\mbox{\includegraphics[trim=42mm 210mm 47mm 0mm, scale=0.7,clip]{figs/softstack-r2.pdf}}
    \mbox{\includegraphics[trim=27mm 208mm 29mm 0mm, scale=0.7,clip]{figs/softstack-r4.pdf}}
    \caption{Software stack for coarray features}\label{fig:layer}
  \end{center}
\end{figure}


%===========================================================
\subsubsection{Fortran wrapper}
%===========================================================

Each set of Fortran wrapper procedures has a generic name 
and dozens of the corresponding specific names.
For example, the object code contains a call to a function with
the generic name ``{\tt xmpf\_coarray\_get\_generic}''.
If the data is two-dimensional array of 16-byte complex type,
the Fortran compiler selects the corresponding specific name 
``{\tt xmpf\_coarray\_get2d\_z16}'' at compile time,
and generates the object code with calling a ULR function 
by the specific name.

The Fortran wrapper accepts Fortran array notations as the arguments 
and the result variable, and converts them into some structures 
which can be handled in the runtime library written in C.
%
It also converts a C pointer to a Fortran pointer with the shape, using
the Cray pointer.

The Fortran wrapper calls ULR procedures basically and 
directly MPI library functions for collective communications.


%本実装では、Fortranの高級な仕様（配列記述や総称名手続き）を
%runtime libraryインタフェースとした。
%これにより、コンパイラが生成すべきオブジェクトインタフェースの数を
%数十分の一に削減してデータの型と形状をruntimeに伝えることができる
%ようになった。


%Actually, the interface is used through the Fortran~90 generic interface
%to ease the code generation by the coarray translator.
%For example, let us convert an {\tt ALLOCATE} statement
%{\tt allocate (a(1:10,2:19))}, where {\tt a} is an allocatable coarray of 16-byte,
%using object-ULR interface {\tt XMPCO\_malloc\_coarray}.
%The translator may generate a call to the generic procedure \\
%{\tt xmpf_coarray_malloc_generic(descriptor_of_a, a, 


%===========================================================
\subsubsection{Upper-layer runtime library (ULR)}
%===========================================================

The major role of ULR is performing the algorithms for coarray data
allocation/registration (\Sec{alloc}) and PUT/GET communications (\Sec{putget}).
Additionally for atomic communications caused by intrinsic subroutines
{\tt ATOMIC\_DEFINE} and {\tt ATOMIC\_REF}, 
ULR calls the corresponding function of LLR after address calculation.

%===========================================================
\subsubsection{Lower-layer runtime library (LLR)}
%===========================================================

LLR basically abstracts the difference between the communication libraries.
The only exception is about allocation and registration of coarray data.
Major functions are shown bellow.

\begin{itemize}
\item
Functions to allocate and register coarray variables,
and functions to register coarray variables that are already allocated.
They are alternatively used in the RS and RA methods and in the CA method.
Corresponding to each, a set of functions to deregister and deallocate and
a set of functions to deregister are provided.

\item
Fundamental functions for RDMA-DMA GET communication and DMA-RDMA PUT communication.
It is assumed that both remote and local data are previously registered.
Blocking and non-blocking can be switched.
% and the only way to wait for
% the completion of the non-blocking communication is using the function
%corresponding to {\tt SYNC MEMORY}.

\item
Functions corresponding to image control statements, atomic subroutines,
and inquire functions.

\end{itemize}

LLR also has the features for multi-dimensional data developed for the C 
implementation, which are not used in the Fortran implementation because
it is solved in ULR.


%===========================================================
\subsubsection{Communication libraries}
%===========================================================

MPI-3 can be selected for all platform on which MPI-3 is implemented. Coarrays are 
registered and deregistered at the start and end point of the MPI window. 
Coarrays are performed one-sided communication by {\tt MPI\_Put} and {\tt MPI\_Get},
and synchronized by {\tt MPI\_Win\_fence}. 
Implementation on MPI incurs certain costs for dynamic allocation of coarrays and 
waiting for communication completion.

GASNet can be selected for more advanced implementation over InfiniBand. 
Since allocation and registration of are inseparable and can be done only once 
on GASNet, the implementation allocates and registers a pool of memory
whose size should be large enough to contain all static and allocatable coarrays.
The XMP runtime should allocate and deallocate coarrays not using the Fortran 
library but using the memory manager made for the pool.

FJ-RDMA can be selected for the implementation over Tofu interconnect of 
the K computer and Fujitsu PRIMEHPC FX series supercomputers. 
Basically, each coarray is allocated by the Fortran library and registered 
the address with the FJ-RDMA interface {\tt FJMPI\_Rdma\_reg\_mem}. 
And it is deregistered with {\tt FJMPI\_Rdma\_dereg\_mem} before deallocated 
(freed) by the Fortran library. 
One-sided communication is performed with {\tt FJMPI\_Rdma\_put} and 
{\tt FJMPI\_Rdma\_get}.
%, which include confirmation of communication completion. <-- 本当？　いつも？



