Figure 3 describes the algorithm of the PUT communication 
implemented in XMP runtime. First, data contiguity, i.e., how long and periodic the 
local and remote data objects are contiguous, is detected. In general, an n''-dimensional'' 
 array a can be k''-dimensionally contiguous''  (0≤k≤n), and the length of a contiguous 
unit is

bytes, where SIZE is 
the Fortran intrinsic function used to obtain the extent of the dimension i of the 
array a. Either DMA or the buffering scheme is selected heuristically depending on 
the underlying communication library. An important necessary condition to select 
the DMA scheme is that the local data is found already registered or can be registered 
with low cost before the communication. The buffering scheme is divided into four 
algorithms depending on the buffer size B and the lengths of the local and remote 
contiguous units NL and NR, respectively. Due to the Fortran syntax rule, NL is a 
multiple of NR or NR is a multiple of NL. If B is large enough, PUT communication 
is caused for each size of NR (cases 1 and 2). Otherwise, it is caused for each size 
of B (cases 3 and 4). If NL is smaller than B, some of the data units are stacked 
in the buffer in order to reduce the number of communications (cases 2 and 3). 
The 
GET communication algorithm is very similar. However, instead of the repetitive stack 
and PUT, it performs the repetitive GET and unstack. 
The characteristics of this 
communication algorithm are as follows:
Only the RDMA-DMA communication pattern is 
required to the underlying communication library. Even if the buffering scheme is 
selected, the buffer is previously allocated and registered for the DMA access.
No 
passive buffer is used to accept any data or request from other images. This algorithm 
does not use the remote procedure call and accesses the remote coarray data without 
disturbing the execution of the other images. The only exception is the pointer component 
of a remote coarray structure, which means a local address on the remote image. 
The 
memory usage is scalable because only one static size local buffer is commonly used 
for PUT and GET communication.
In the CAF language specification, a reference of 
a coindexed variable requires such quick completion of GET communication that the 
following execution statements may soon refer to the data. Therefore, the GET communication 
is implemented as blocking communications in the default. However, PUT can often 
be relaxed simply by a checking data dependency at runtime. The buffering scheme 
can use a non-blocking communication unless the target remote storage is overlapped 
with previous non-blocking communications.




communication libraryによっては、Fortranランタイムシステムが割付けた領域を効率的な
片側通信の対象にすることができない。その場合には、communication libraryが提供する方法で
割付けた領域をFortranランタイムシステムに渡してFortranの変数であると認識させる実装が
求められる。
また、データを片側通信の対象とするためには、communication libraryにそれを {\em register}
しなければならない。communication libraryはその領域をRDMAの対象とするためのpin-downなどの
必要な前処理を行う必要があるからである。
registrationコストの削減のためには、すべてのnon-allocatable coarrayは１カ所にまとめて
利用者プログラムの実行開始前に１回だけ行うようにするのが望ましい。






MPIとくらべたcoarrayの優位性はarray sectionを効率よく表現できることだ。
Fortran 90 以降Fortranに導入された配列式、配列代入の機能はそのまま
coarray put/get communicationの表記に活かされている。
つまりarray sectionはデータの部分を表現するとともに通信の範囲やパターンを表現する。
MPIでは後者はMPI\_typeなどを使って次元毎に再帰的に表現し直さなければならない。

また、RDMA可能かどうかはコンパイラとruntime上位で判断できる。

