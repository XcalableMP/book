\section{Compiler Implementation for high performance}\label{sec:compiler}

communication libraryによっては、Fortranランタイムシステムが割付けた領域を効率的な
片側通信の対象にすることができない。その場合には、communication libaryが提供する方法で
割付けた領域をFortranランタイムシステムに渡してFortranの変数であると認識させる実装が
求められる。
また、データを片側通信の対象とするためには、commnication libraryにそれを {\em register}
しなければならない。commnucation libraryはその領域をRDMAの対象とするためのpin-downなどの
必要な前処理を行う必要があるからである。
registrationコストの削減のためには、すべてのnon-allocatable coarrayは１カ所にまとめて
利用者プログラムの実行開始前に１回だけ行うようにするのが望ましい。






MPIとくらべたcoarrayの優位性はarray sectionを効率よく表現できることだ。
Fortran 90 以降Fortranに導入された配列式、配列代入の機能はそのまま
coarray put/get communicationの表記に活かされている。
つまりarray sectionはデータの部分を表現するとともに通信の範囲やパターンを表現する。
MPIでは後者はMPI\_typeなどを使って次元毎に再帰的に表現し直さなければならない。

また、RDMA可能かどうかはコンパイラとruntime上位で判断できる。



\subsubsection{static coarrayの高速化}

全部まとめて先にallocするコンパイラ技術

定数評価、構造体の大きめな見積り

\subsubsection{allocatable coarrayの高速化}

lower level communication libraryに合わせてallocation methodを選択

runtimelibshare事前に巨大領域を取る

実行時allocのコストが大きいとき


runtimeliballocation実行時allocのコストが小さいとき

\subsubsection{contiguouity検出による高速化}
次元を跨ぐ連続性抽出

\subsubsection{バッファリング}
有限サイズ、基礎データから、nlocal, nremote, nbufの関係でアルゴリズム
commpilerallocationfortranがallocateしてregisterできるとき



