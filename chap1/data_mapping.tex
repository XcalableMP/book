\section{Data Mapping}

\subsection{{\tt nodes} Directive}

The {\tt nodes} directive declares the name of a node array and its shape. A
node array can be multi-dimensional.

%\subsubsection{One-dimensional Node Set}

\begin{XCexample}
#pragma xmp nodes p[4]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(4)
\end{XFexample}

The nodes directive declares 1-dimensional node set p which has four
nodes. In XMP/C, the node set consists of p[0], p[1], p[2], and p[3]. In
XMP/Fortran, the node set consists of p(1), p(2), p(3), and p(4).

\subsubsection{Multi-dimensional Node Set}

\begin{XCexample}
#pragma xmp nodes p[2][3]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(3,2)
\end{XFexample}

The \|nodes| directive declares two-dimensional node array \|p| that
includes six nodes. In XMP/C, the node set includes \|p[0][0]|,
\|p[0][1]|, \|p[0][2]|, \|p[1][0]|, \|p[1][1]|, and \|p[1][2]|. In
XMP/Fortran, the node set includes \|p(1,1)|, \|p(2,1)|, \|p(3,1)|,
\|p(1,2)|, \|p(2,2)|, and \|p(3,2)|.

\begin{mynote}
  The ordering of the elements in a node array depends on the base
  language, that is, C or Fortran. 
\end{mynote}

%\subsubsection{Dynamic Node Set}

\begin{XCexample}
#pragma xmp nodes p[*]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(*)
\end{XFexample}

An asterisk can be specified in the \|nodes| directive to declare a
{\it dynamic} node array. In the above program, one-dimensional dynamic
node array \|p| is declared with an asterisk. The size of a dynamic node
array is determined at runtime (at the beginning of the execution). For example,
when the user runs the sample program with three nodes, the node array \|p|
include three nodes.

The user also can declare multi-dimensional dynamic nodes with an
asterisk.

\begin{XCexample}
#pragma xmp nodes p[*][3]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(3,*)
\end{XFexample}

When the user runs the sample program with 12 nodes, the node array \|p| will
have a shape of 4x3, in C, or 3x4, in Fortran.

\begin{mynote}
  The user can put an asterisk only in the last dimension of the node array.
\end{mynote}

\begin{myhint}
  The dynamic node array may interfere with compiler optimizations.  In
  general, static one achieve better performance.
\end{myhint}

%\subsubsection{Partial Node Set}

The user can declare a node subarray derived from the existing node
array. Node subarrays can be used, for example, to optimize inter-node
communication by reducing the number of nodes participating in the
communication.

\begin{XCexample}
#pragma xmp nodes p[16]
#pragma xmp nodes q[8]=p[0:8]
#pragma xmp nodes r[4][2]=p[8:8]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(16)
!$xmp nodes q(8)=p(1:8)
!$xmp nodes r(2,4)=p(9:16)
\end{XFexample}

In line 1, a node array \|p| inclusing 16 nodes is declared. In line 2, a
node subarray \|q| derived from the first half of \|p| is declared. In line 3, a
two-dimensional node subarray \|r| derived from the latter half of \|p| is declared.

The user can declare a n-dimensional node subarray derived from a m-dimensional one.

\begin{XCexample}
#pragma xmp nodes p[4][2]
#pragma xmp nodes row[4]=p[:][*]
#pragma xmp nodes col[2]=p[*][:]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(2,4)
!$xmp nodes row(4)=p(*,:)
!$xmp nodes col(2)=p(:,*)
\end{XFexample}

In line 1, a two-dimensional node array \|p| including 4x2 nodes is
declared. In line 2, a node subarray \|row| derived from a single row of
\|p| is declared. In line 3, a node subarray \|col| derived from a
single column of \|p| is declared.

A colon represents a triplet which indicate all possible indices in the
dimension.
%
An asterisk indicate the index of the current executing node in the
dimension.
%
For example, \|col[2]| is \|p[0][0:2]| on nodes \|p[0][0]| and
\|p[0][1]|, and is \|p[1][0:2]| on nodes \|p[1][0]| and \|p[1][1]| in
XMP/C. Similarly, \|col(2)| is \|p(1:2,1)| on nodes \|p(1,1)| and
\|p(2,1)|, and is \|p(1:2,2)| on nodes \|p(1,2)| \|p(2,2)| in
XMP/Fortran.

\begin{figure}
  \centering
  \includegraphics{figs/row_col.png}
  \caption{Partial node set.}
  \label{fig:partial}
\end{figure}

In XMP/C, both p[0][0] and p[0][1] will be row[0]. Likewise, p[0][0],
p[1][0], p[2][0] and p[3][0] will be col[0] in each execution
context. In XMP/Fortran, both p(1,1) and p(2,1) will be
row(1). Likewise, p(1,1), p(1,2), p(1,3) and p(1,4) will be col(1) in
each context.

\begin{mynote}
The semantics of an asterisk in a
node reference is different from that in a declaraion.
\end{mynote}


\subsection{{\tt template} Directive}

The \|template| directive declares the name and shape of a
template.
%  Templates are virtual arrays which used for data and work 
% mapping. They can have multi-dimensional shapes.

%\subsubsection{One-dimensional Template}

\begin{XCexample}
#pragma xmp template t[10]
\end{XCexample}

\begin{XFexample}
!$xmp template t(10)
\end{XFexample}

The \|template| directive declares a one-dimensional template \|t|
having ten elements. Templates are indexed in the similar manner to
arrays in the base languages. For the above examples, the template \|t|
is indexed from zero to nine (i.e. \|t[0]| $\cdots$ \|t[9]|) in XMP/C
while from one to ten (i.e. \|t(1)| $\cdots$ \|t(10)|)in XMP/Fortran.

\begin{myhint}
% In general, the user declare templates which has the same
% size with the target data array.
  In many cases, a template should be declared to have the same shape as
  your target array.
\end{myhint}

% In XMP/Fortran, the start index of the template can be given by an
% arbitrary number to match the starting array index in the base
% language.

% \begin{XFexample}
% !$xmp template t(-5:4)
% \end{XFexample}

% The template directive declares 1-dimensional template t starting from t(-5) to t(4).

% \begin{mynote}
% In XMP/C, templates should start from 0 since array indices
% start from 0 in the C language.
% \end{mynote}

%\subsubsection{Multi-dimensional Template}

\begin{XCexample}
#pragma xmp template t[10][20]
\end{XCexample}

\begin{XFexample}
!$xmp template t(20,10)
\end{XFexample}

The \|template| directive declares a two-dimensional template \|t| that
has 10x20 elements. In XMP/C, \|t| is indexed from t[0][0] to t[9][19]
while, in XMP/Fortran, from \|t(1,1)| to \|t(20,10)|.

%\subsubsection{Dynamic Template}

\begin{XCexample}
#pragma xmp template t[:]
\end{XCexample}

\begin{XFexample}
!$xmp template t(:)
\end{XFexample}

In the above examples, a colon instead of an integer is specified as the
size to declare a one-dimensional dynamic template \|t|. The colon
indicates that the size of the template is not fixed and to be
fixed at runtime by the \|template_fix| construct (Sec. \ref{184243_1Nov19}).


\subsection{{\tt distribute} Directive}

The \|distribute| directive specifies a distribution of the target
template. The user can specify a distribution format of block, cyclic,
block-cyclic, or gblock (i.e. uneven block).


\subsubsection{Block Distribution}

\begin{XCexample}
#pragma xmp distribute t[block] onto p
\end{XCexample}

\begin{XFexample}
!$xmp distribute t(block) onto p
\end{XFexample}

The target template is divided into contiguous blocks and
distributed among nodes.
%
% When the size of the template is $N$ and the
% number of nodes is $K$, the size of each block will be $ceil(N/K)$.
Let's suppose that the size of the template is $N$ and the
number of nodes is $K$. If $N$ is divisible by $K$, a block of size $N/K$
are assigned to each node; otherwise a block of size
$ceil(N/K)$ is assigned to each of $N/ceil(N/K)$ nodes, a block of size
$mod(N,K)$ to one node, and no block to $(K-N/ceil(N/K)-1)$ nodes. 
%
The block distribution is useful for stencil computation.

\begin{mynote}
  The function $ceil(x)$ returns a minimum integer value greater than
  $x$, and $mod(x,y)$ returns $x$ modulo $y$.
\end{mynote}

\begin{XCexample}
#pragma xmp nodes p[3]
#pragma xmp template t[22]
#pragma xmp distribute t[block] onto p
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(3)
!$xmp template t(22)
!$xmp distribute t(block) onto p
\end{XFexample}

\begin{figure}
  \centering
  \includegraphics{figs/block.png}
\end{figure}

Since $ceil(22/3)$ is 8, eight elements are allocated on each of \|p[0]|
and p[1]. And then, remaining six elements are allocated on \|p[2]|.

% The user can explicitly specify the block size.
% In that case, the remaining elements are allocated on the last node.

% \begin{XCexample}
% #pragma xmp nodes p[3]
% #pragma xmp template t[22]
% #pragma xmp distribute t[block(7)] onto p
% \end{XCexample}

% \begin{XFexample}
% !$xmp nodes p(3)
% !$xmp template t(22)
% !$xmp distribute t(block(7)) onto p
% \end{XFexample}

% \begin{figure}
%   \centering
%   \includegraphics{figs/block2.png}
% \end{figure}

% Seven elements will be allocated on the p[0] and p[1], as specified in
% the directive. And then remaining 8 elements will be allocated on the
% last node p[2].


\subsubsection{Cyclic Distribution}

\begin{XCexample}
#pragma xmp distribute t[cyclic] onto p
\end{XCexample}

\begin{XFexample}
!$xmp distribute t(cyclic) onto p
\end{XFexample}

The target template is divided into chunks of size one and
distributed among nodes in a round-robin manner.
%
The cyclic distribution is usefull for the case where the load on each
element of the template is not balanced.
%suitable for computation with an irregular
%load%balance of data and computation.

\begin{XCexample}
#pragma xmp nodes p[3]
#pragma xmp template t[22]
#pragma xmp distribute t[cyclic] onto p
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(3)
!$xmp template t(22)
!$xmp distribute t(cyclic) onto p
\end{XFexample}

\begin{figure}
  \centering
  \includegraphics{figs/cyclic.png}
\end{figure}


\subsubsection{Block-cyclic Distribution}

\begin{XCexample}
#pragma xmp distribute t[cyclic(w)] onto p
\end{XCexample}

\begin{XFexample}
!$xmp distribute t(cyclic(w)) onto p
\end{XFexample}

The target template is divided into chunks of size \|w| and distributed
among nodes in a round-robin manner.
%
The block-cyclic distribution is usefull for the case where the load on
each element of the template is not balanced but the locality of the
elements is required.

% Block-cyclic distribution is
% suitable for computation which has an irregular load balance and
% references to neighborhood elements.

\begin{XCexample}
#pragma xmp nodes p[3]
#pragma xmp template t[22]
#pragma xmp distribute t[cyclic(3)] onto p
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(3)
!$xmp template t(22)
!$xmp distribute t(cyclic(3)) onto p
\end{XFexample}

\begin{figure}
  \centering
  \includegraphics{figs/block-cyclic.png}
\end{figure}


\subsubsection{Gblock Distribution}

\begin{XCexample}
#pragma xmp distribute t[gblock(W)] onto p
\end{XCexample}

\begin{XFexample}
!$xmp distribute t(gblock(W)) onto p
\end{XFexample}

The target template is divided into contiguous blocks of size \|W[0]|,
\|W[1]|, $\cdots$, in XMP/C, or \|W(1)|, \|W(2)|, $\cdots$, in
XMP/Fortran, and distributed among nodes .
%
An array \|W| is called a mapping array.
%
The user can specify irregular (uneven) block distribution with gblock.
%a special type of data distribution explicitly by using
%mapping arrays (e.g. distribution of triangular matrix).

\begin{XCexample}
#pragma xmp nodes p[3]
#pragma xmp template t[22]
int W[3] = {6, 11, 5};
#pragma xmp distribute t[gblock(W)] onto p
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(3)
!$xmp template t(22)
integer, parameter :: W(3) = (/6,11,5/)
!$xmp distribute t(gblock(W)) onto p
\end{XFexample}

\begin{figure}
  \centering
  \includegraphics{figs/gblock.png}
\end{figure}

The user can specify an asterisk instead of a mapping array the in
gblock distribution to defer fixing the actual distribution.
%
In such a case, the actual distribution will be fixed at runtime by 
using {\tt template\_fix} construct.


\subsubsection{Distribution of Multi-dimensional Templates}

The user can distribute a multi-dimensional template onto
a node array.

\begin{XCexample}
#pragma xmp nodes p[2][2]
#pragma xmp template t[10][10]
#pragma xmp distribute t[block][block] onto p
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(2,2)
!$xmp template t(10,10)
!$xmp distribute t(block,block) onto p
\end{XFexample}

The \|distribute| directive declares the distribution of a two-dimensional
template \|t| ong a two-dimensional node array \|p|. Each dimension of the
template is divided in block and each rectangular regtion is assigned to a
node.

\begin{figure}
  \centering
  \includegraphics{figs/multi.png}
\end{figure}

The user can specify a different distribution format in each of the
dimension of a template.

\begin{XCexample}
#pragma xmp nodes p[2][2]
#pragma xmp template t[10][10]
#pragma xmp distribute t[block][cyclic] onto p
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(2,2)
!$xmp template t(10,10)
!$xmp distribute t(cyclic,block) onto p
\end{XFexample}

\begin{figure}
  \centering
  \includegraphics{figs/multi2.png}
\end{figure}

When an asterisk is specified in the \|distribute| directive as
a distribution format, the target dimension is``non-distributed.'' In
the following example, the first dimension will be distributed in a
block manner and the second dimension will is non-distributed.

\begin{XCexample}
#pragma xmp nodes p[4]
#pragma xmp template t[10][10]
#pragma xmp distribute t[block][*] onto p
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(4)
!$xmp template t(10,10)
!$xmp distribute t(*,block) onto p
\end{XFexample}

\begin{figure}
  \centering
  \includegraphics{figs/multi3.png}
\end{figure}



\subsection{{\tt align} Directive}

% The {\tt align} directive performs data mapping and distributes data
% among nodes by using a distributed template. The {\tt align} directive
% must follow the definition of the target template.

The align directive specifies that an array is to be mapped in the same
way as a specified template.
% As a result of this directive, an array is ``distributed'' onto nodes.

%\subsubsection{Normal Alignment}

\begin{XCexample}
#pragma xmp nodes p[4]
#pragma xmp template t[8]
#pragma xmp distribute t[block] onto p
int a[8];
#pragma xmp align a[i] with t[i]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(4)
!$xmp template t(8)
!$xmp distribute t(block) onto p
integer :: a(8)
!$xmp align a(i) with t(i)
\end{XFexample}

The array \|a| is decomposed and laid out so that each array element
\|a(i)| is colocated with the corresponding template element \|t(i)|.

% The {\tt align} directive aligns the owner node of a[i] with t(i), a
% distributed template. As a result, array a is distributed among the node
% set p.

\begin{figure}
  \centering
  \includegraphics{figs/1dim.png}
\end{figure}

The \|align| directive can also be used for multi-dimensional arrays.

\begin{XCexample}
#pragma xmp nodes p[2][2]
#pragma xmp template t[8][8]
#pragma xmp distribute t[block][block] onto p
int a[8][8];
#pragma xmp align a[i][j] with t[i][j]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(2,2)
!$xmp template t(8,8)
!$xmp distribute t(block,block) onto p
integer :: a(8,8)
!$xmp align a(j,i) with t(j,i)
\end{XFexample}

\begin{figure}
  \centering
  \includegraphics{figs/multi-dim.png}
\end{figure}

%\subsubsection{Special Alignment}

%\paragraph{Collapse}

The user can align a two-dimensional array with a one-dimensional template.

\begin{XCexample}
#pragma xmp nodes p[4]
#pragma xmp template t[8]
#pragma xmp distribute t[block] onto p
int a[8][8];
#pragma xmp align a[i][*] with t[i]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(4)
!$xmp template t(8)
!$xmp distribute t(block) onto p
integer :: a(8,8)
!$xmp align a(*,i) with t(i)
\end{XFexample}

When an asterisk is specified as a subscript in a dimension of the
target array in the \|align| directive, the dimension is not
distributed. In the sample program above, the first dimension of the
array {\tt a} is distributed onto the node array \|p| while the second
dimension is ``collapsed.''

\begin{figure}
  \centering
  \includegraphics{figs/collapse.png}
\end{figure}

In XMP/C, {\tt a[0:2][:]} will be allocated on {\tt p[0]} while, in
XMP/Fortran, \|a(:,1:2)| will be allocated on \|p(1)|.

%\paragraph{Replicate}

The user also can align a one-dimensional array with a two-dimensional
template.

\begin{XCexample}
#pragma xmp nodes p[2][2]
#pragma xmp template t[8][8]
#pragma xmp distribute t[block][block] onto p
int a[8];
#pragma xmp align a[i] with t[i][*]
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(2,2)
!$xmp template t(8,8)
!$xmp distribute t(block,block) onto p
integer :: a(8)
!$xmp align a(i) with t(*,i)
\end{XFexample}

When an asterisk is specified as a subscript in a dimension of the
target template in the \|align| directive, the array will be
``replicated'' along the axis of the dimension.

\begin{figure}
  \centering
  \includegraphics{figs/replicate.png}
\end{figure}

In XMP/C, \|a[0:4]| will be replicated and allocated on p[0][0] and
p[0][1] while, in XMP/Fortran, \|a(1:4)| will be allocated on \|p(1,1)|
and \|p(2,1)|.




\subsection{Dynamic Allocation of Distributed Array}

This section explains how distributed (i.e. global) arrays are allocated
at runtime. The basic procedure is common in XMP/C and XMP/Fortran with
a few specific difference.

%\subsubsection{One-dimensional Array}

\begin{XCexample}
#pragma xmp nodes p[4]
#pragma xmp template t[N]
#pragma xmp distribute t[block] onto p
float *a;
#pragma xmp align a[i] with t[i]
  :
a = xmp_malloc(xmp_desc_of(a), N);
\end{XCexample}

In XMP/C, first, declare a pointer of the type of the target array; 
%
second, align it as if it were an array;
%
finally, allocate memory for it with the {\tt xmp\_malloc()}
function. {\tt xmp\_desc\_of()} is an 
intrinsic/builtin function that returns the descriptor of the XMP object
specified by the argument.

\begin{XFexample}
!$xmp nodes p(4)
!$xmp template t(N)
!$xmp distribute t(block) onto p
real, allocatable :: a(:)
!$xmp align a(i) with t(i)

allocate(a(N))
\end{XFexample}

In XMP/Fortran, first, declare an allocatable array; Second, align it;
finally, allocate memory for it with the \|allocate| statement.

%\subsubsection{Multi-dimensional Array}

For multi-dimensional arrays, the procedure is the same as that for 
one-dimensional arrays.

\begin{XCexample}
#pragma xmp nodes p[2][2]
#pragma xmp template t[N1][N2]
#pragma xmp distribute t[block][block] onto p
float (*a)[N2];
#pragma xmp align a[i][j] with t[i][j]
  :
a = (float (*)[N2])xmp_malloc(xmp_desc_of(a), N1, N2);
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(2,2)
!$xmp template t(N2,N1)
!$xmp distribute t(block,block) onto p
real, allocatable :: a(:,:)
!$xmp align a(j,i) with t(j,i)
  :
allocate(a(N2,N1))
\end{XFexample}

\begin{mynote}
  If the size of the template is not fixed until runtime, you have to
  use the \|template_fix| construct.
\end{mynote}


\subsection{{\tt template\_fix} Construct}
\label{184243_1Nov19}

The \|template_fix| construct fixes the shape and/or the distribution of
an undefined template. 
%It is also used when a distributed array is allocated at runtime.

\begin{XCexample}
#pragma xmp nodes p[4]
#pragma xmp template t[:]
#pragma xmp distribute t[block] onto p
double *a;
#pragma xmp align a[i] with t[i]

int n = 100;
#pragma xmp template_fix t[n]
a = xmp_malloc(xmp_desc_of(a), n);
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(4)
!$xmp template t(:)
!$xmp distribute t(block) onto p
real, allocatable :: a(:)
integer :: n
!$xmp align a(i) with t(i)

n = 100
!$xmp template_fix t(n)
allocate(a(n))
\end{XFexample}

In the above sample code, 
%
first, a template \|t| whose size is undefined (``\|:|'') is declared;
%
second, a pointer \|a| in XMP/C or an allocatable array \|a| in
XMP/Fortran is aligned with the template;
%
third, the size of the template is fixed with a \|template_fix|
construct;
%
finally, the pointer or the allocatable array is allocated with the
\|xmp_malloc()| builtin function in XMP/C or the \|allocate| statement
in XMP/Fortran, respectively.

\begin{mynote}
{\tt template\_fix} constructs can be applied to a template only once.
\end{mynote}

This construct can also be used to fix a mapping array of a template
that is distributed in ``\|gblock(*)|`` at declaration.

\begin{XCexample}
#pragma xmp nodes p[4]
#pragma xmp template t[:]
#pragma xmp distribute t[gblock(*)] onto p
double *a;
#pragma xmp align a[i] with t[i]

int n = 100;
int m[] = {40,30,20,10};

#pragma xmp template_fix[gblock(m)] t[n]
a = xmp_malloc(xmp_desc_of(a), n);
\end{XCexample}

\begin{XFexample}
!$xmp nodes p(4)
!$xmp template t(:)
!$xmp distribute t(gblock) onto p
real, allocatable :: a(:)
integer :: n, m(4)
!$xmp align a(i) with t(i)

n = 100
m(:) = (/40,30,20,10/)
!$xmp template_fix(gblock(m)) t(n)
allocate(a(n))
\end{XFexample}
